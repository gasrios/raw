/*
 * Â© ğŸğŸğŸğŸ‘ ğ†ğ®ğ¢ğ¥ğ¡ğğ«ğ¦ğ ğ‘ğ¢ğ¨ğ¬ ğ€ğ¥ğ¥ ğ‘ğ¢ğ ğ¡ğ­ğ¬ ğ‘ğğ¬ğğ«ğ¯ğğ
 *
 * ğ‘‡â„ğ‘–ğ‘  ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š ğ‘–ğ‘  ğ‘“ğ‘Ÿğ‘’ğ‘’ ğ‘ ğ‘œğ‘“ğ‘¡ğ‘¤ğ‘ğ‘Ÿğ‘’: ğ‘¦ğ‘œğ‘¢ ğ‘ğ‘ğ‘› ğ‘Ÿğ‘’ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘–ğ‘ğ‘¢ğ‘¡ğ‘’ ğ‘–ğ‘¡ ğ‘ğ‘›ğ‘‘/ğ‘œğ‘Ÿ ğ‘šğ‘œğ‘‘ğ‘–ğ‘“ğ‘¦ ğ‘–ğ‘¡ ğ‘¢ğ‘›ğ‘‘ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ ğ‘¡ğ‘’ğ‘Ÿğ‘šğ‘  ğ‘œğ‘“ ğ‘¡â„ğ‘’
 * ğºğ‘ğ‘ˆ ğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘™ ğ‘ƒğ‘¢ğ‘ğ‘™ğ‘–ğ‘ ğ¿ğ‘–ğ‘ğ‘’ğ‘›ğ‘ ğ‘’ ğ‘ğ‘  ğ‘ğ‘¢ğ‘ğ‘™ğ‘–ğ‘ â„ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘¡â„ğ‘’ ğ¹ğ‘Ÿğ‘’ğ‘’ ğ‘†ğ‘œğ‘“ğ‘¡ğ‘¤ğ‘ğ‘Ÿğ‘’ ğ¹ğ‘œğ‘¢ğ‘›ğ‘‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›, ğ‘£ğ‘’ğ‘Ÿğ‘ ğ‘–ğ‘œğ‘› 3 ğ‘œğ‘“ ğ‘¡â„ğ‘’
 * ğ¿ğ‘–ğ‘ğ‘’ğ‘›ğ‘ ğ‘’.
 *
 * ğ‘‡â„ğ‘–ğ‘  ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š ğ‘–ğ‘  ğ‘‘ğ‘–ğ‘ ğ‘¡ğ‘Ÿğ‘–ğ‘ğ‘¢ğ‘¡ğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ â„ğ‘œğ‘ğ‘’ ğ‘¡â„ğ‘ğ‘¡ ğ‘–ğ‘¡ ğ‘¤ğ‘–ğ‘™ğ‘™ ğ‘ğ‘’ ğ‘¢ğ‘ ğ‘’ğ‘“ğ‘¢ğ‘™, ğ‘ğ‘¢ğ‘¡ ğ‘Šğ¼ğ‘‡ğ»ğ‘‚ğ‘ˆğ‘‡ ğ´ğ‘ğ‘Œ ğ‘Šğ´ğ‘…ğ‘…ğ´ğ‘ğ‘‡ğ‘Œ;
 * ğ‘¤ğ‘–ğ‘¡â„ğ‘œğ‘¢ğ‘¡ ğ‘’ğ‘£ğ‘’ğ‘› ğ‘¡â„ğ‘’ ğ‘–ğ‘šğ‘ğ‘™ğ‘–ğ‘’ğ‘‘ ğ‘¤ğ‘ğ‘Ÿğ‘Ÿğ‘ğ‘›ğ‘¡ğ‘¦ ğ‘œğ‘“ ğ‘€ğ¸ğ‘…ğ¶ğ»ğ´ğ‘ğ‘‡ğ´ğµğ¼ğ¿ğ¼ğ‘‡ğ‘Œ ğ‘œğ‘Ÿ ğ¹ğ¼ğ‘‡ğ‘ğ¸ğ‘†ğ‘† ğ¹ğ‘‚ğ‘… ğ´ ğ‘ƒğ´ğ‘…ğ‘‡ğ¼ğ¶ğ‘ˆğ¿ğ´ğ‘… ğ‘ƒğ‘ˆğ‘…ğ‘ƒğ‘‚ğ‘†ğ¸. ğ‘†ğ‘’ğ‘’
 * ğ‘¡â„ğ‘’ ğºğ‘ğ‘ˆ ğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘™ ğ‘ƒğ‘¢ğ‘ğ‘™ğ‘–ğ‘ ğ¿ğ‘–ğ‘ğ‘’ğ‘›ğ‘ ğ‘’ ğ‘“ğ‘œğ‘Ÿ ğ‘šğ‘œğ‘Ÿğ‘’ ğ‘‘ğ‘’ğ‘¡ğ‘ğ‘–ğ‘™ğ‘ .
 *
 * ğ‘Œğ‘œğ‘¢ ğ‘ â„ğ‘œğ‘¢ğ‘™ğ‘‘ â„ğ‘ğ‘£ğ‘’ ğ‘Ÿğ‘’ğ‘ğ‘’ğ‘–ğ‘£ğ‘’ğ‘‘ ğ‘ ğ‘ğ‘œğ‘ğ‘¦ ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğºğ‘ğ‘ˆ ğºğ‘’ğ‘›ğ‘’ğ‘Ÿğ‘ğ‘™ ğ‘ƒğ‘¢ğ‘ğ‘™ğ‘–ğ‘ ğ¿ğ‘–ğ‘ğ‘’ğ‘›ğ‘ ğ‘’ ğ‘ğ‘™ğ‘œğ‘›ğ‘” ğ‘¤ğ‘–ğ‘¡â„ ğ‘¡â„ğ‘–ğ‘  ğ‘ğ‘Ÿğ‘œğ‘”ğ‘Ÿğ‘ğ‘š. ğ¼ğ‘“
 * ğ‘›ğ‘œğ‘¡, ğ‘ ğ‘’ğ‘’ â„ğ‘¡ğ‘¡ğ‘://ğ‘¤ğ‘¤ğ‘¤.ğ‘”ğ‘›ğ‘¢.ğ‘œğ‘Ÿğ‘”/ğ‘™ğ‘–ğ‘ğ‘’ğ‘›ğ‘ ğ‘’ğ‘ /.
 */

use data::{
    type_size, Byte, Double, Float, Long, Sbyte, Short, Slong, Sshort, Tag, Undefined, ASCII,
    DOUBLE, FLOAT, LONG, SBYTE, SHORT, SLONG, SSHORT,
};
use std::collections::HashMap;
use std::io::{Error, ErrorKind, Read, Seek, SeekFrom};

/*
 * ğ…ğ«ğ¨ğ¦ ğƒğ¢ğ ğ¢ğ­ğšğ¥ ğğğ ğšğ­ğ¢ğ¯ğ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ•ğğ«ğ¬ğ¢ğ¨ğ§ ğŸ.ğŸ’.ğŸ.ğŸ, ğ©ğšğ ğ ğŸğŸ‘
 *
 * ğ·ğ‘ğº ğ‘Ÿğ‘’ğ‘ğ‘œğ‘šğ‘šğ‘’ğ‘›ğ‘‘ğ‘  ğ‘¡â„ğ‘’ ğ‘¢ğ‘ ğ‘’ ğ‘œğ‘“ ğ‘†ğ‘¢ğ‘ğ¼ğ¹ğ· ğ‘¡ğ‘Ÿğ‘’ğ‘’ğ‘ , ğ‘ğ‘  ğ‘‘ğ‘’ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘‡ğ¼ğ¹ğ¹-ğ¸ğ‘ƒ ğ‘ ğ‘ğ‘’ğ‘ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›. ğ‘†ğ‘¢ğ‘ğ¼ğ¹ğ· ğ‘â„ğ‘ğ‘–ğ‘›ğ‘ 
 * ğ‘ğ‘Ÿğ‘’ ğ‘›ğ‘œğ‘¡ ğ‘ ğ‘¢ğ‘ğ‘ğ‘œğ‘Ÿğ‘¡ğ‘’ğ‘‘.
 *
 * ğ‘‡â„ğ‘’ â„ğ‘–ğ‘”â„ğ‘’ğ‘ ğ‘¡-ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘¢ğ‘¡ğ‘–ğ‘œğ‘› ğ‘ğ‘›ğ‘‘ ğ‘ğ‘¢ğ‘ğ‘™ğ‘–ğ‘¡ğ‘¦ ğ¼ğ¹ğ· ğ‘ â„ğ‘œğ‘¢ğ‘™ğ‘‘ ğ‘¢ğ‘ ğ‘’ ğ‘ğ‘’ğ‘¤ğ‘†ğ‘¢ğ‘ğ¹ğ‘–ğ‘™ğ‘’ğ‘‡ğ‘¦ğ‘ğ‘’ ğ‘’ğ‘ğ‘¢ğ‘ğ‘™ ğ‘¡ğ‘œ 0. ğ‘…ğ‘’ğ‘‘ğ‘¢ğ‘ğ‘’ğ‘‘ ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘¢ğ‘¡ğ‘–ğ‘œğ‘›
 * (ğ‘œğ‘Ÿ ğ‘ğ‘¢ğ‘ğ‘™ğ‘–ğ‘¡ğ‘¦) ğ‘¡â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘ğ‘–ğ‘™ğ‘  ğ‘œğ‘Ÿ ğ‘ğ‘Ÿğ‘’ğ‘£ğ‘–ğ‘’ğ‘¤ğ‘ , ğ‘–ğ‘“ ğ‘ğ‘›ğ‘¦, ğ‘ â„ğ‘œğ‘¢ğ‘™ğ‘‘ ğ‘¢ğ‘ ğ‘’ ğ‘ğ‘’ğ‘¤ğ‘†ğ‘¢ğ‘ğ¹ğ‘–ğ‘™ğ‘’ğ‘‡ğ‘¦ğ‘ğ‘’ ğ‘’ğ‘ğ‘¢ğ‘ğ‘™ ğ‘¡ğ‘œ 1 (ğ‘“ğ‘œğ‘Ÿ ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘šğ‘ğ‘Ÿğ‘¦
 * ğ‘ğ‘Ÿğ‘’ğ‘£ğ‘–ğ‘’ğ‘¤) ğ‘œğ‘Ÿ 10001.ğ» (ğ‘“ğ‘œğ‘Ÿ ğ‘ğ‘› ğ‘ğ‘™ğ‘¡ğ‘’ğ‘Ÿğ‘›ğ‘ğ‘¡ğ‘’ ğ‘ğ‘Ÿğ‘’ğ‘£ğ‘–ğ‘’ğ‘¤).
 *
 * ğ·ğ‘ğº ğ‘Ÿğ‘’ğ‘ğ‘œğ‘šğ‘šğ‘’ğ‘›ğ‘‘ğ‘ , ğ‘ğ‘¢ğ‘¡ ğ‘‘ğ‘œğ‘’ğ‘  ğ‘›ğ‘œğ‘¡ ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘–ğ‘Ÿğ‘’, ğ‘¡â„ğ‘ğ‘¡ ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘Ÿğ‘ ğ‘¡ ğ¼ğ¹ğ· ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘› ğ‘ ğ‘™ğ‘œğ‘¤-ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘¢ğ‘¡ğ‘–ğ‘œğ‘› ğ‘¡â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘ğ‘–ğ‘™, ğ‘ğ‘ 
 * ğ‘‘ğ‘’ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘‡ğ¼ğ¹ğ¹-ğ¸ğ‘ƒ ğ‘ ğ‘ğ‘’ğ‘ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›.
 *
 * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ…/ğ„ğ, ğ©ğšğ ğ ğŸğŸ
 *
 * ğ´ ğ‘†ğ‘¢ğ‘ğ¼ğ¹ğ·ğ‘  ğ‘¡ğ‘ğ‘” ğ‘–ğ‘› ğ‘¡â„ğ‘’ 0ğ‘¡â„ ğ¼ğ¹ğ· ğ‘–ğ‘  ğ‘¢ğ‘ ğ‘’ğ‘‘ ğ‘¡ğ‘œ ğ‘ğ‘œğ‘–ğ‘›ğ‘¡ ğ‘¡ğ‘œ ğ‘¡â„ğ‘’ ğ‘ğ‘œğ‘šğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘’ğ‘‘ ğ‘“ğ‘¢ğ‘™ğ‘™-ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘¢ğ‘¡ğ‘–ğ‘œğ‘› ğ‘–ğ‘šğ‘ğ‘”ğ‘’. ğ¼ğ‘“ ğ‘¡â„ğ‘’
 * ğ‘“ğ‘¢ğ‘™ğ‘™-ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘¢ğ‘¡ğ‘–ğ‘œğ‘› ğ‘–ğ‘šğ‘ğ‘”ğ‘’ ğ‘–ğ‘  ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’ğ‘‘ ğ‘¢ğ‘›ğ‘ğ‘œğ‘šğ‘ğ‘Ÿğ‘’ğ‘ ğ‘ ğ‘’ğ‘‘ ğ‘ğ‘  ğ‘ ğ‘ğ‘ğ‘ ğ‘’ğ‘™ğ‘–ğ‘›ğ‘’-ğ‘Ÿğ‘’ğ‘ğ‘‘ğ‘ğ‘ğ‘™ğ‘’ ğ‘‡ğ¼ğ¹ğ¹ ğ‘–ğ‘šğ‘ğ‘”ğ‘’, ğ‘¡â„ğ‘’ ğ‘“ğ‘¢ğ‘™ğ‘™-
 * ğ‘Ÿğ‘’ğ‘ ğ‘œğ‘™ğ‘¢ğ‘¡ğ‘–ğ‘œğ‘› ğ‘–ğ‘šğ‘ğ‘”ğ‘’ ğ‘ğ‘œğ‘¢ğ‘™ğ‘‘ ğ‘ğ‘’ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ 0ğ‘¡â„ ğ¼ğ¹ğ·. ğ»ğ‘œğ‘¤ğ‘’ğ‘£ğ‘’ğ‘Ÿ, ğ‘‡ğ¼ğ¹ğ¹/ğ¸ğ‘ƒ ğ‘Ÿğ‘’ğ‘ğ‘œğ‘šğ‘šğ‘’ğ‘›ğ‘‘ğ‘  ğ‘¡â„ğ‘ğ‘¡ ğ‘ ğ‘¡â„ğ‘¢ğ‘šğ‘ğ‘›ğ‘ğ‘–ğ‘™
 * ğ‘–ğ‘šğ‘ğ‘”ğ‘’ ğ‘ğ‘’ ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ 0ğ‘¡â„ ğ¼ğ¹ğ·.
 */
pub struct Dng {
    pub ifd0: Ifd,
    pub hires_ifd: Ifd,
}

pub struct Ifd {
    pub fields: HashMap<Tag, Field>,
    pub offset: u64,
}

#[derive(Debug)]
pub enum Field {
    Byte(Vec<Byte>),
    Ascii(String),
    Short(Vec<Short>),
    Long(Vec<Long>),
    // TODO Rational(Vec<u8>),
    Sbyte(Vec<Sbyte>),
    Undefined(Vec<Undefined>),
    Sshort(Vec<Sshort>),
    Slong(Vec<Slong>),
    // TODO Srational(Vec<u8>),
    Float(Vec<Float>),
    Double(Vec<Double>),
}

pub struct TiffReader<R> {
    reader: R,
    endianness: Endianness,
}

pub enum Endianness {
    Uninitialized,
    BigEndian,
    LittleEndian,
}

impl<R: Read + Seek> TiffReader<R> {
    /// # Errors
    ///
    /// Only those caused by the underlying reader
    pub fn new(reader: R) -> Result<TiffReader<R>, Error> {
        Ok(TiffReader {
            reader,
            endianness: Endianness::Uninitialized,
        })
    }

    /// # Panics
    ///
    /// Only when underlying reader panics
    ///
    /// # Errors
    ///
    /// Those caused by the underlying reader, plus nonconformance to DNG 1.4.0.0
    pub fn read_dng(&mut self) -> Result<Dng, Error> {
        let offset: u64 = self.process_header()?;

        let ifd0 = self.process_ifd(offset)?;

        /*
         * ğ…ğ«ğ¨ğ¦ ğƒğ¢ğ ğ¢ğ­ğšğ¥ ğğğ ğšğ­ğ¢ğ¯ğ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ•ğğ«ğ¬ğ¢ğ¨ğ§ ğŸ.ğŸ’.ğŸ.ğŸ, ğ©ğšğ ğ ğŸğŸ‘
         *
         * ğ·ğ‘ğº ğ‘Ÿğ‘’ğ‘ğ‘œğ‘šğ‘šğ‘’ğ‘›ğ‘‘ğ‘  ğ‘¡â„ğ‘’ ğ‘¢ğ‘ ğ‘’ ğ‘œğ‘“ ğ‘†ğ‘¢ğ‘ğ¼ğ¹ğ· ğ‘¡ğ‘Ÿğ‘’ğ‘’ğ‘ , ğ‘ğ‘  ğ‘‘ğ‘’ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘‡ğ¼ğ¹ğ¹-ğ¸ğ‘ƒ ğ‘ ğ‘ğ‘’ğ‘ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›.
         * ğ‘†ğ‘¢ğ‘ğ¼ğ¹ğ· ğ‘â„ğ‘ğ‘–ğ‘›ğ‘  ğ‘ğ‘Ÿğ‘’ ğ‘›ğ‘œğ‘¡ ğ‘ ğ‘¢ğ‘ğ‘ğ‘œğ‘Ÿğ‘¡ğ‘’ğ‘‘.
         */
        if ifd0.offset != 0 {
            return Err(Error::new(
                ErrorKind::InvalidData,
                "DNG recommends the use of SubIFD trees, as described in the TIFF-EP specification. SubIFD chains are not supported.",
            ));
        }

        if let Some(field) = ifd0.fields.get(&Tag::SubIFDs) {
            if let Field::Long(sub_ifds) = field {
                if sub_ifds.len() != 1 {
                    /*
                     * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ…/ğ„ğ, ğ©ğšğ ğ ğŸğŸ
                     *
                     * ğ‘‡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘¤ğ‘–ğ‘™ğ‘™ ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘¡ğ‘œ ğ‘¡â„ğ‘’ â€œğ‘¡ğ‘Ÿğ‘’ğ‘’ğ‘‘â€ ğ¼ğ¹ğ· ğ‘–ğ‘¡ğ‘ ğ‘’ğ‘™ğ‘“ ğ‘–ğ‘“ ğ‘=1, ğ‘œğ‘¡â„ğ‘’ğ‘Ÿğ‘¤ğ‘–ğ‘ ğ‘’ ğ‘¡â„ğ‘’
                     * ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘¤ğ‘–ğ‘™ğ‘™ ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘› ğ‘ğ‘› ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘¡ğ‘œ ğ‘ ğ‘™ğ‘œğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘› ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘›ğ‘–ğ‘›ğ‘” ğ‘ğ‘› ğ‘ğ‘Ÿğ‘Ÿğ‘ğ‘¦ ğ‘œğ‘“ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ğ‘  ğ‘¡ğ‘œ ğ‘’ğ‘ğ‘â„
                     * ğ¼ğ¹ğ· ğ‘ğ‘’ğ‘–ğ‘›ğ‘” â€œğ‘¡ğ‘Ÿğ‘’ğ‘’ğ‘‘â€ ğ‘“ğ‘Ÿğ‘œğ‘š ğ‘¡â„ğ‘’ ğ‘ğ‘¢ğ‘Ÿğ‘Ÿğ‘’ğ‘›ğ‘¡ ğ¼ğ¹ğ·. ğ‘‡â„ğ‘–ğ‘  ğ‘ğ‘Ÿğ‘Ÿğ‘ğ‘¦ ğ‘œğ‘“ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ğ‘  ğ‘¤ğ‘–ğ‘™ğ‘™ ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘› ğ‘
                     * ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘–ğ‘’ğ‘ , ğ‘–.ğ‘’. ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘œğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘  ğ‘¡ğ‘œ ğ‘ ğ¼ğ¹ğ·ğ‘ . ğ‘ªğ’–ğ’“ğ’“ğ’†ğ’ğ’•ğ’ğ’š, ğ‘µ=1, ğ’‚ğ’ğ’… ğ’•ğ’‰ğ’† ğ‘½ğ’‚ğ’ğ’–ğ’† ğ’„ğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’”
                     * ğ’•ğ’‰ğ’† ğ’ğ’‡ğ’‡ğ’”ğ’†ğ’• ğ’•ğ’ ğ’•ğ’‰ğ’† ğ‘°ğ‘­ğ‘« ğ’„ğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’Šğ’ğ’ˆ ğ’•ğ’‰ğ’† ğ’‡ğ’–ğ’ğ’ ğ’“ğ’†ğ’”ğ’ğ’ğ’–ğ’•ğ’Šğ’ğ’ ğ’Šğ’ğ’‚ğ’ˆğ’†.
                     *
                     * ğ‘ˆğ‘ ğ‘ğ‘”ğ‘’: ğ¼ğ¹ğ·0
                     */
                    return Err(Error::new(
                        ErrorKind::InvalidData,
                        "\"SubIFDs\" should only contain the offset to the IFD containing the full resolution image.",
                    ));
                }

                let offset: u64 = u64::from(sub_ifds[0]);

                Ok(Dng {
                    ifd0,
                    hires_ifd: self.process_ifd(offset)?,
                })
            } else {
                Err(Error::new(
                    ErrorKind::InvalidData,
                    "\"SubIFDs\" should have type \"long\".",
                ))
            }
        } else {
            Err(Error::new(
                ErrorKind::InvalidData,
                "TIFF/EP recommends that a thumbnail image be stored in the 0th IFD",
            ))
        }
    }

    fn process_header(&mut self) -> Result<u64, Error> {
        /*
         * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ… ğŸ”.ğŸ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ©ğšğ ğ ğŸğŸ‘
         *
         * ğ¼ğ‘šğ‘ğ‘”ğ‘’ ğ¹ğ‘–ğ‘™ğ‘’ ğ»ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ
         *
         * ğ´ ğ‘‡ğ¼ğ¹ğ¹ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘ğ‘’ğ‘”ğ‘–ğ‘›ğ‘  ğ‘¤ğ‘–ğ‘¡â„ ğ‘ğ‘› 8-ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘–ğ‘šğ‘ğ‘”ğ‘’ ğ‘“ğ‘–ğ‘™ğ‘’ â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ, ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘›ğ‘–ğ‘›ğ‘” ğ‘¡â„ğ‘’ ğ‘“ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘–ğ‘›ğ‘”
         * ğ‘–ğ‘›ğ‘“ğ‘œğ‘Ÿğ‘šğ‘ğ‘¡ğ‘–ğ‘œğ‘›:
         *
         * ğµğ‘¦ğ‘¡ğ‘’ğ‘  0-1: ğ‘‡â„ğ‘’ ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ ğ‘¢ğ‘ ğ‘’ğ‘‘ ğ‘¤ğ‘–ğ‘¡â„ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘™ğ‘’. ğ¿ğ‘’ğ‘”ğ‘ğ‘™ ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ğ‘  ğ‘ğ‘Ÿğ‘’:
         *            â€œğ¼ğ¼â€ (4949.ğ»)
         *            â€œğ‘€ğ‘€â€ (4ğ·4ğ·.ğ»)
         *
         *            ğ¼ğ‘› ğ‘¡â„ğ‘’ â€œğ¼ğ¼â€ ğ‘“ğ‘œğ‘Ÿğ‘šğ‘ğ‘¡, ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ ğ‘–ğ‘  ğ‘ğ‘™ğ‘¤ğ‘ğ‘¦ğ‘  ğ‘“ğ‘Ÿğ‘œğ‘š ğ‘¡â„ğ‘’ ğ‘™ğ‘’ğ‘ğ‘ ğ‘¡ ğ‘ ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘¡ ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘¡ğ‘œ
         *            ğ‘¡â„ğ‘’ ğ‘šğ‘œğ‘ ğ‘¡ ğ‘ ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘¡ ğ‘ğ‘¦ğ‘¡ğ‘’, ğ‘“ğ‘œğ‘Ÿ ğ‘ğ‘œğ‘¡â„ 16-ğ‘ğ‘–ğ‘¡ ğ‘ğ‘›ğ‘‘ 32-ğ‘ğ‘–ğ‘¡ ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘”ğ‘’ğ‘Ÿğ‘  ğ‘‡â„ğ‘–ğ‘  ğ‘–ğ‘  ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘‘
         *            ğ‘™ğ‘–ğ‘¡ğ‘¡ğ‘™ğ‘’-ğ‘’ğ‘›ğ‘‘ğ‘–ğ‘ğ‘› ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ. ğ¼ğ‘› ğ‘¡â„ğ‘’ â€œğ‘€ğ‘€â€ ğ‘“ğ‘œğ‘Ÿğ‘šğ‘ğ‘¡, ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ ğ‘–ğ‘  ğ‘ğ‘™ğ‘¤ğ‘ğ‘¦ğ‘  ğ‘“ğ‘Ÿğ‘œğ‘š ğ‘šğ‘œğ‘ ğ‘¡
         *            ğ‘ ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘¡ ğ‘¡ğ‘œ ğ‘™ğ‘’ğ‘ğ‘ ğ‘¡ ğ‘ ğ‘–ğ‘”ğ‘›ğ‘–ğ‘“ğ‘–ğ‘ğ‘ğ‘›ğ‘¡, ğ‘“ğ‘œğ‘Ÿ ğ‘ğ‘œğ‘¡â„ 16-ğ‘ğ‘–ğ‘¡ ğ‘ğ‘›ğ‘‘ 32-ğ‘ğ‘–ğ‘¡ ğ‘–ğ‘›ğ‘¡ğ‘’ğ‘”ğ‘’ğ‘Ÿğ‘ . ğ‘‡â„ğ‘–ğ‘ 
         *            ğ‘–ğ‘  ğ‘ğ‘ğ‘™ğ‘™ğ‘’ğ‘‘ ğ‘ğ‘–ğ‘”-ğ‘’ğ‘›ğ‘‘ğ‘–ğ‘ğ‘› ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ.
         */
        let buffer: [u8; 2] = self.read_to_stack()?;
        if buffer[0] == 0x49 && buffer[1] == 0x49 {
            self.endianness = Endianness::LittleEndian;
        } else if buffer[0] == 0x4D && buffer[1] == 0x4D {
            self.endianness = Endianness::BigEndian;
        } else {
            return Err(Error::new(
            ErrorKind::InvalidData,
                format!(
                    "Invalid byte order specification: {:?}. Legal values are â€œIIâ€ (4949.H) and â€œMMâ€ (4D4D.H)",
                    &buffer
                ),
            ));
        }

        /*
         * ğµğ‘¦ğ‘¡ğ‘’ğ‘  2-3: ğ´ğ‘› ğ‘ğ‘Ÿğ‘ğ‘–ğ‘¡ğ‘Ÿğ‘ğ‘Ÿğ‘¦ ğ‘ğ‘¢ğ‘¡ ğ‘ğ‘ğ‘Ÿğ‘’ğ‘“ğ‘¢ğ‘™ğ‘™ğ‘¦ ğ‘â„ğ‘œğ‘ ğ‘’ğ‘› ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ (42) ğ‘¡â„ğ‘ğ‘¡ ğ‘“ğ‘¢ğ‘Ÿğ‘¡â„ğ‘’ğ‘Ÿ ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘“ğ‘–ğ‘’ğ‘  ğ‘¡â„ğ‘’
         *            ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘ğ‘  ğ‘ ğ‘‡ğ¼ğ¹ğ¹ ğ‘“ğ‘–ğ‘™ğ‘’.
         *
         *            ğ‘‡â„ğ‘’ ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘Ÿğ‘‘ğ‘’ğ‘Ÿ ğ‘‘ğ‘’ğ‘ğ‘’ğ‘›ğ‘‘ğ‘  ğ‘œğ‘› ğ‘¡â„ğ‘’ ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘œğ‘“ ğµğ‘¦ğ‘¡ğ‘’ğ‘  0-1.
         */
        let version: u16 = self.read_u16()?;
        if version != 42 {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("Failed to further identify the file as a TIFF file, was expecting 42, found {version}"),
            ));
        }

        /*
         * ğµğ‘¦ğ‘¡ğ‘’ğ‘  4-7: ğ‘‡â„ğ‘’ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ (ğ‘–ğ‘› ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘ ) ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘Ÿğ‘ ğ‘¡ ğ¼ğ¹ğ·. ğ‘‡â„ğ‘’ ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘¦ ğ‘šğ‘ğ‘¦ ğ‘ğ‘’ ğ‘ğ‘¡ ğ‘ğ‘›ğ‘¦ ğ‘™ğ‘œğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›
         *            ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘ğ‘“ğ‘¡ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ ğ‘ğ‘¢ğ‘¡ ğ‘šğ‘¢ğ‘ ğ‘¡ ğ‘ğ‘’ğ‘”ğ‘–ğ‘› ğ‘œğ‘› ğ‘ ğ‘¤ğ‘œğ‘Ÿğ‘‘ ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘ğ‘ğ‘Ÿğ‘¦. ğ¼ğ‘›
         *            ğ‘ğ‘ğ‘Ÿğ‘¡ğ‘–ğ‘ğ‘¢ğ‘™ğ‘ğ‘Ÿ, ğ‘ğ‘› ğ¼ğ‘šğ‘ğ‘”ğ‘’ ğ¹ğ‘–ğ‘™ğ‘’ ğ·ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘¦ ğ‘šğ‘ğ‘¦ ğ‘“ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ ğ‘¡â„ğ‘’ ğ‘–ğ‘šğ‘ğ‘”ğ‘’ ğ‘‘ğ‘ğ‘¡ğ‘ ğ‘–ğ‘¡ ğ‘‘ğ‘’ğ‘ ğ‘ğ‘Ÿğ‘–ğ‘ğ‘’ğ‘ .
         *            ğ‘…ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿğ‘  ğ‘šğ‘¢ğ‘ ğ‘¡ ğ‘“ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ ğ‘¡â„ğ‘’ ğ‘ğ‘œğ‘–ğ‘›ğ‘¡ğ‘’ğ‘Ÿğ‘  ğ‘¤â„ğ‘’ğ‘Ÿğ‘’ğ‘£ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ğ‘¦ ğ‘šğ‘ğ‘¦ ğ‘™ğ‘’ğ‘ğ‘‘.
         *
         *            ğ‘‡â„ğ‘’ ğ‘¡ğ‘’ğ‘Ÿğ‘š ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘–ğ‘  ğ‘ğ‘™ğ‘¤ğ‘ğ‘¦ğ‘  ğ‘¢ğ‘ ğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘–ğ‘  ğ‘‘ğ‘œğ‘ğ‘¢ğ‘šğ‘’ğ‘›ğ‘¡ ğ‘¡ğ‘œ ğ‘Ÿğ‘’ğ‘“ğ‘’ğ‘Ÿ ğ‘¡ğ‘œ ğ‘ ğ‘™ğ‘œğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘›
         *            ğ‘¤ğ‘–ğ‘¡â„ ğ‘Ÿğ‘’ğ‘ ğ‘ğ‘’ğ‘ğ‘¡ ğ‘¡ğ‘œ ğ‘¡â„ğ‘’ ğ‘ğ‘’ğ‘”ğ‘–ğ‘›ğ‘›ğ‘–ğ‘›ğ‘” ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘‡ğ¼ğ¹ğ¹ ğ‘“ğ‘–ğ‘™ğ‘’. ğ‘‡â„ğ‘’ ğ‘“ğ‘–ğ‘Ÿğ‘ ğ‘¡ ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘™ğ‘’
         *            â„ğ‘ğ‘  ğ‘ğ‘› ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘œğ‘“ 0.
         */
        let offset: u64 = self.read_offset()?;

        /*
         * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ… ğŸ”.ğŸ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ©ğšğ ğ ğŸğŸ’
         *
         * ğ‘‡â„ğ‘’ğ‘Ÿğ‘’ ğ‘šğ‘¢ğ‘ ğ‘¡ ğ‘ğ‘’ ğ‘ğ‘¡ ğ‘™ğ‘’ğ‘ğ‘ ğ‘¡ 1 ğ¼ğ¹ğ· ğ‘–ğ‘› ğ‘ ğ‘‡ğ¼ğ¹ğ¹ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘ğ‘›ğ‘‘ ğ‘’ğ‘ğ‘â„ ğ¼ğ¹ğ· ğ‘šğ‘¢ğ‘ ğ‘¡ â„ğ‘ğ‘£ğ‘’ ğ‘ğ‘¡ ğ‘™ğ‘’ğ‘ğ‘ ğ‘¡ ğ‘œğ‘›ğ‘’ ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘¦.
         *
         * As a side effect, we also fail here if offset == 0, that is, there are no IFDs in the
         * file.
         */
        if offset < 8 {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("First IFD offset is smaller than header size: {offset}"),
            ));
        }

        Ok(offset)
    }

    fn process_ifd(&mut self, offset: u64) -> Result<Ifd, Error> {
        self.reader.seek(SeekFrom::Start(offset))?;

        let mut fields: HashMap<Tag, Field> = HashMap::<Tag, Field>::new();

        /*
         * Note: TIFF 6.0 Specification uses the terms "IFD Entry" and "field" with the same
         * meaning, this is sometimes confusing.
         */

        /*
         * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ… ğŸ”.ğŸ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ©ğšğ ğ ğŸğŸ’
         *
         * ğ¼ğ‘šğ‘ğ‘”ğ‘’ ğ¹ğ‘–ğ‘™ğ‘’ ğ·ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘¦
         *
         * ğ´ğ‘› ğ¼ğ‘šğ‘ğ‘”ğ‘’ ğ¹ğ‘–ğ‘™ğ‘’ ğ·ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘¦ (ğ¼ğ¹ğ·) ğ‘ğ‘œğ‘›ğ‘ ğ‘–ğ‘ ğ‘¡ğ‘  ğ‘œğ‘“ ğ‘ 2-ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ ğ‘œğ‘“ ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘¦
         * ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘–ğ‘’ğ‘  (ğ‘–.ğ‘’., ğ‘¡â„ğ‘’ ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ ğ‘œğ‘“ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ğ‘ ), ğ‘“ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘ ğ‘ ğ‘’ğ‘ğ‘¢ğ‘’ğ‘›ğ‘ğ‘’ ğ‘œğ‘“ 12-ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘–ğ‘’ğ‘ ,
         * ğ‘“ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘ 4-ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘›ğ‘’ğ‘¥ğ‘¡ ğ¼ğ¹ğ· (ğ‘œğ‘Ÿ 0 ğ‘–ğ‘“ ğ‘›ğ‘œğ‘›ğ‘’). (ğ·ğ‘œ ğ‘›ğ‘œğ‘¡ ğ‘“ğ‘œğ‘Ÿğ‘”ğ‘’ğ‘¡ ğ‘¡ğ‘œ ğ‘¤ğ‘Ÿğ‘–ğ‘¡ğ‘’ ğ‘¡â„ğ‘’
         * 4 ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘  ğ‘œğ‘“ 0 ğ‘ğ‘“ğ‘¡ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ ğ‘™ğ‘ğ‘ ğ‘¡ ğ¼ğ¹ğ·.)
         *
         * ğ‘‡â„ğ‘’ğ‘Ÿğ‘’ ğ‘šğ‘¢ğ‘ ğ‘¡ ğ‘ğ‘’ ğ‘ğ‘¡ ğ‘™ğ‘’ğ‘ğ‘ ğ‘¡ 1 ğ¼ğ¹ğ· ğ‘–ğ‘› ğ‘ ğ‘‡ğ¼ğ¹ğ¹ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘ğ‘›ğ‘‘ ğ‘’ğ‘ğ‘â„ ğ¼ğ¹ğ· ğ‘šğ‘¢ğ‘ ğ‘¡ â„ğ‘ğ‘£ğ‘’ ğ‘ğ‘¡ ğ‘™ğ‘’ğ‘ğ‘ ğ‘¡ ğ‘œğ‘›ğ‘’ ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘¦.
         */
        let number_of_fields: u16 = self.read_u16()?;
        for _i in 0..number_of_fields {
            /*
             * ğ¼ğ¹ğ· ğ¸ğ‘›ğ‘¡ğ‘Ÿğ‘¦
             *
             * ğ¸ğ‘ğ‘â„ 12-ğ‘ğ‘¦ğ‘¡ğ‘’ ğ¼ğ¹ğ· ğ‘’ğ‘›ğ‘¡ğ‘Ÿğ‘¦ â„ğ‘ğ‘  ğ‘¡â„ğ‘’ ğ‘“ğ‘œğ‘™ğ‘™ğ‘œğ‘¤ğ‘–ğ‘›ğ‘” ğ‘“ğ‘œğ‘Ÿğ‘šğ‘ğ‘¡:
             *
             * ğµğ‘¦ğ‘¡ğ‘’ğ‘  0-1 ğ‘‡â„ğ‘’ ğ‘‡ğ‘ğ‘” ğ‘¡â„ğ‘ğ‘¡ ğ‘–ğ‘‘ğ‘’ğ‘›ğ‘¡ğ‘–ğ‘“ğ‘–ğ‘’ğ‘  ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘.
             */
            let tag: Tag = self.read_tag()?;

            /*
             * TODO we do not need to know or process all tags, remove the ones we don't care about
             * uncomment this after testing is done.
            if tag == Tag::Unknown {
                break;
            }
             */

            /*
             * ğµğ‘¦ğ‘¡ğ‘’ğ‘  2-3 ğ‘‡â„ğ‘’ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ ğ‘‡ğ‘¦ğ‘ğ‘’.
             */
            let type_: u16 = self.read_u16()?;

            /*
             * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ… ğŸ”.ğŸ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ©ğšğ ğ ğŸğŸ’
             *
             * ğ‘Šğ‘ğ‘Ÿğ‘›ğ‘–ğ‘›ğ‘”: ğ¼ğ‘¡ ğ‘–ğ‘  ğ‘ğ‘œğ‘ ğ‘ ğ‘–ğ‘ğ‘™ğ‘’ ğ‘¡â„ğ‘ğ‘¡ ğ‘œğ‘¡â„ğ‘’ğ‘Ÿ ğ‘‡ğ¼ğ¹ğ¹ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ ğ‘¡ğ‘¦ğ‘ğ‘’ğ‘  ğ‘¤ğ‘–ğ‘™ğ‘™ ğ‘ğ‘’ ğ‘ğ‘‘ğ‘‘ğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘“ğ‘¢ğ‘¡ğ‘¢ğ‘Ÿğ‘’. ğ‘…ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿğ‘  ğ‘ â„ğ‘œğ‘¢ğ‘™ğ‘‘
             *          ğ‘ ğ‘˜ğ‘–ğ‘ ğ‘œğ‘£ğ‘’ğ‘Ÿ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ğ‘  ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘›ğ‘–ğ‘›ğ‘” ğ‘ğ‘› ğ‘¢ğ‘›ğ‘’ğ‘¥ğ‘ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘ ğ‘¡ğ‘¦ğ‘ğ‘’.
             */
            if type_ < 1 {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    "A field type cannot be zero",
                ));
            }
            if type_ > 12 {
                break;
            }

            /*
             * ğµğ‘¦ğ‘¡ğ‘’ğ‘  4-7 ğ‘‡â„ğ‘’ ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ ğ‘œğ‘“ ğ‘£ğ‘ğ‘™ğ‘¢ğ‘’ğ‘ , ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡ ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘–ğ‘›ğ‘‘ğ‘–ğ‘ğ‘ğ‘¡ğ‘’ğ‘‘ ğ‘‡ğ‘¦ğ‘ğ‘’.
             */
            let count: u32 = self.read_u32()?;

            if count < 1 {
                return Err(Error::new(
                    ErrorKind::InvalidData,
                    format!("Field should have at least one value: {count}"),
                ));
            }

            fields.insert(tag, self.read_ifd_field(type_, count)?);
        }

        Ok(Ifd {
            fields,
            offset: self.read_offset()?,
        })
    }

    fn read_tag(&mut self) -> Result<Tag, Error> {
        Ok(Tag::new(self.read_u16()?))
    }

    fn read_ifd_field(&mut self, type_: u16, count: u32) -> Result<Field, Error> {
        let size: usize =
            type_size(type_) * <u32 as std::convert::TryInto<usize>>::try_into(count).unwrap();
        let mut buffer: Vec<u8> = Vec::with_capacity(size);
        buffer.spare_capacity_mut();
        unsafe {
            /*
             * See https://rust-lang.github.io/rust-clippy/master/index.html#uninit_vec
             * See https://doc.rust-lang.org/std/vec/struct.Vec.html#method.spare_capacity_mut
             *
             * This is a Rust hack, but it is OK, because we do not read data until after we have
             * written it, which we do below, before returning from this function.
             */
            buffer.set_len(size);
        }

        /*
         * ğµğ‘¦ğ‘¡ğ‘’ğ‘  8-11 ğ‘‡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘‚ğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡, ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ (ğ‘–ğ‘› ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘ ) ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘“ğ‘œğ‘Ÿ ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘.
         *
         * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ… ğŸ”.ğŸ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ©ğšğ ğ ğŸğŸ“
         *
         * ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’/ğ‘‚ğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡
         *
         * ğ‘‡ğ‘œ ğ‘ ğ‘ğ‘£ğ‘’ ğ‘¡ğ‘–ğ‘šğ‘’ ğ‘ğ‘›ğ‘‘ ğ‘ ğ‘ğ‘ğ‘ğ‘’ ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘‚ğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡ ğ‘ğ‘œğ‘›ğ‘¡ğ‘ğ‘–ğ‘›ğ‘  ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘–ğ‘›ğ‘ ğ‘¡ğ‘’ğ‘ğ‘‘ ğ‘œğ‘“ ğ‘ğ‘œğ‘–ğ‘›ğ‘¡ğ‘–ğ‘›ğ‘” ğ‘¡ğ‘œ
         * ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘–ğ‘“ ğ‘ğ‘›ğ‘‘ ğ‘œğ‘›ğ‘™ğ‘¦ ğ‘–ğ‘“ ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘“ğ‘–ğ‘¡ğ‘  ğ‘–ğ‘›ğ‘¡ğ‘œ 4 ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘ . ğ¼ğ‘“ ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘–ğ‘  ğ‘ â„ğ‘œğ‘Ÿğ‘¡ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘ğ‘› 4
         * ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘ , ğ‘–ğ‘¡ ğ‘–ğ‘  ğ‘™ğ‘’ğ‘“ğ‘¡-ğ‘—ğ‘¢ğ‘ ğ‘¡ğ‘–ğ‘“ğ‘–ğ‘’ğ‘‘ ğ‘¤ğ‘–ğ‘¡â„ğ‘–ğ‘› ğ‘¡â„ğ‘’ 4-ğ‘ğ‘¦ğ‘¡ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘‚ğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡, ğ‘–.ğ‘’., ğ‘ ğ‘¡ğ‘œğ‘Ÿğ‘’ğ‘‘ ğ‘–ğ‘› ğ‘¡â„ğ‘’
         * ğ‘™ğ‘œğ‘¤ğ‘’ğ‘Ÿ-ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿğ‘’ğ‘‘ ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘ . ğ‘Šâ„ğ‘’ğ‘¡â„ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ ğ‘‰ğ‘ğ‘™ğ‘¢ğ‘’ ğ‘“ğ‘–ğ‘¡ğ‘  ğ‘¤ğ‘–ğ‘¡â„ğ‘–ğ‘› 4 ğ‘ğ‘¦ğ‘¡ğ‘’ğ‘  ğ‘–ğ‘  ğ‘‘ğ‘’ğ‘¡ğ‘’ğ‘Ÿğ‘šğ‘–ğ‘›ğ‘’ğ‘‘ ğ‘ğ‘¦ ğ‘¡â„ğ‘’
         * ğ‘‡ğ‘¦ğ‘ğ‘’ ğ‘ğ‘›ğ‘‘ ğ¶ğ‘œğ‘¢ğ‘›ğ‘¡ ğ‘œğ‘“ ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘’ğ‘™ğ‘‘.
         */
        if size > 4 {
            let offset: u64 = self.read_offset()?;
            let current_offset: u64 = self.reader.stream_position()?;
            self.reader.seek(SeekFrom::Start(offset))?;
            self.read_to(&mut buffer)?;
            self.reader.seek(SeekFrom::Start(current_offset))?;
        } else {
            self.read_to(&mut buffer)?;
            self.reader
                .seek(SeekFrom::Current((4 - size).try_into().unwrap()))?;
        }

        Ok(match type_ {
            // TODO
            ASCII => to_ascii_field(&buffer),
            SHORT => self.to_short_field(&buffer)?,
            LONG => self.to_long_field(&buffer)?,
            SBYTE => self.to_sbyte_field(&buffer)?,
            SSHORT => self.to_sshort_field(&buffer)?,
            SLONG => self.to_slong_field(&buffer)?,
            FLOAT => self.to_float_field(&buffer)?,
            DOUBLE => self.to_double_field(&buffer)?,
            // Covers BYTE and UNDEFINED
            _ => Field::Byte(buffer),
        })
    }

    fn read_offset(&mut self) -> Result<u64, Error> {
        // TIFF uses 32 bit for offsets, but std::io::Seek expects 64 bits
        let offset: u64 = u64::from(self.read_u32()?);

        /*
         * ğ…ğ«ğ¨ğ¦ ğ“ğˆğ…ğ… ğŸ”.ğŸ ğ’ğ©ğğœğ¢ğŸğ¢ğœğšğ­ğ¢ğ¨ğ§, ğ©ğšğ ğ ğŸğŸ‘
         *
         * ğ‘‡â„ğ‘’ ğ‘‘ğ‘–ğ‘Ÿğ‘’ğ‘ğ‘¡ğ‘œğ‘Ÿğ‘¦ ğ‘šğ‘ğ‘¦ ğ‘ğ‘’ ğ‘ğ‘¡ ğ‘ğ‘›ğ‘¦ ğ‘™ğ‘œğ‘ğ‘ğ‘¡ğ‘–ğ‘œğ‘› ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘“ğ‘–ğ‘™ğ‘’ ğ‘ğ‘“ğ‘¡ğ‘’ğ‘Ÿ ğ‘¡â„ğ‘’ â„ğ‘’ğ‘ğ‘‘ğ‘’ğ‘Ÿ ğ‘ğ‘¢ğ‘¡ ğ‘šğ‘¢ğ‘ ğ‘¡ ğ‘ğ‘’ğ‘”ğ‘–ğ‘› ğ‘œğ‘› ğ‘ ğ‘¤ğ‘œğ‘Ÿğ‘‘
         * ğ‘ğ‘œğ‘¢ğ‘›ğ‘‘ğ‘ğ‘Ÿğ‘¦.
         */
        if offset % 2 == 1 {
            return Err(Error::new(
                ErrorKind::InvalidData,
                format!("Value offset is odd and therefore not a word boundary: {offset}"),
            ));
        }
        Ok(offset)
    }

    fn read_u16(&mut self) -> Result<u16, Error> {
        let buffer: [u8; 2] = self.read_to_stack()?;
        Ok(match self.endianness {
            Endianness::LittleEndian => u16::from_le_bytes(buffer),
            Endianness::BigEndian => u16::from_be_bytes(buffer),
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn read_u32(&mut self) -> Result<u32, Error> {
        let buffer: [u8; 4] = self.read_to_stack()?;
        Ok(match self.endianness {
            Endianness::LittleEndian => u32::from_le_bytes(buffer),
            Endianness::BigEndian => u32::from_be_bytes(buffer),
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    /*
     * This may be overoptimizing, but I already had a function to read fixed size arrays before I
     * realized I would also need one to read vectors.
     *
     * I may remove this function in case it looks like it became redundant and offers no benefit.
     */
    fn read_to_stack<const SIZE: usize>(&mut self) -> Result<[u8; SIZE], Error> {
        let mut buffer: [u8; SIZE] = [0u8; SIZE];
        self.read_to(&mut buffer)?;
        Ok(buffer)
    }

    fn read_to(&mut self, buffer: &mut [u8]) -> Result<(), Error> {
        let bytes_read: usize = self.reader.read(buffer)?;
        if bytes_read != buffer.len() {
            return Err(Error::new(
                ErrorKind::UnexpectedEof,
                format!(
                    "Tried to read {} bytes, found only {bytes_read} bytes available",
                    buffer.len()
                ),
            ));
        }
        Ok(())
    }

    fn to_short_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(SHORT);

        let mut data: Vec<Short> = Vec::<Short>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_short(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Short(data))
    }

    fn to_short(&self, buffer: &[u8]) -> Result<Short, Error> {
        if buffer.len() != 2 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for short: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => Short::from_le_bytes([buffer[0], buffer[1]]),
            Endianness::BigEndian => Short::from_be_bytes([buffer[0], buffer[1]]),
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn to_long_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(LONG);

        let mut data: Vec<Long> = Vec::<Long>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_long(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Long(data))
    }

    fn to_long(&self, buffer: &[u8]) -> Result<Long, Error> {
        if buffer.len() != 4 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for long: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => {
                Long::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
            }
            Endianness::BigEndian => {
                Long::from_be_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
            }
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn to_sbyte_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(SBYTE);

        let mut data: Vec<Sbyte> = Vec::<Sbyte>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_sbyte(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Sbyte(data))
    }

    fn to_sbyte(&self, buffer: &[u8]) -> Result<Sbyte, Error> {
        if buffer.len() != 1 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for sbyte: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => Sbyte::from_le_bytes([buffer[0]]),
            Endianness::BigEndian => Sbyte::from_be_bytes([buffer[0]]),
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn to_sshort_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(SSHORT);

        let mut data: Vec<Sshort> = Vec::<Sshort>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_sshort(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Sshort(data))
    }

    fn to_sshort(&self, buffer: &[u8]) -> Result<Sshort, Error> {
        if buffer.len() != 2 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for sshort: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => Sshort::from_le_bytes([buffer[0], buffer[1]]),
            Endianness::BigEndian => Sshort::from_be_bytes([buffer[0], buffer[1]]),
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn to_slong_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(SLONG);

        let mut data: Vec<Slong> = Vec::<Slong>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_slong(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Slong(data))
    }

    fn to_slong(&self, buffer: &[u8]) -> Result<Slong, Error> {
        if buffer.len() != 4 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for slong: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => {
                Slong::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
            }
            Endianness::BigEndian => {
                Slong::from_be_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
            }
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn to_float_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(FLOAT);

        let mut data: Vec<Float> = Vec::<Float>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_float(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Float(data))
    }

    fn to_float(&self, buffer: &[u8]) -> Result<Float, Error> {
        if buffer.len() != 4 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for float: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => {
                Float::from_le_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
            }
            Endianness::BigEndian => {
                Float::from_be_bytes([buffer[0], buffer[1], buffer[2], buffer[3]])
            }
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }

    fn to_double_field(&self, buffer: &[u8]) -> Result<Field, Error> {
        let size: usize = type_size(DOUBLE);

        let mut data: Vec<Double> = Vec::<Double>::new();
        for i in 0..buffer.len() / size {
            data.push(self.to_double(&buffer[size * i..size * i + size])?);
        }
        Ok(Field::Double(data))
    }

    fn to_double(&self, buffer: &[u8]) -> Result<Double, Error> {
        if buffer.len() != 8 {
            return Err(Error::new(
                ErrorKind::Other,
                format!("Wrong array size for float: {}", buffer.len()),
            ));
        }
        Ok(match self.endianness {
            Endianness::LittleEndian => Double::from_le_bytes([
                buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6],
                buffer[7],
            ]),
            Endianness::BigEndian => Double::from_be_bytes([
                buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6],
                buffer[7],
            ]),
            Endianness::Uninitialized => {
                return Err(Error::new(
                    ErrorKind::Other,
                    "TiffReader was not initialized correctly before read attempt",
                ))
            }
        })
    }
}

fn to_ascii_field(buffer: &[u8]) -> Field {
    let mut lenght: usize = buffer.len();

    // Trim null padded ASCII sequences. Can happen in proprietary tags.
    for i in (0..buffer.len()).rev() {
        if buffer[i] == 0 {
            lenght -= 1;
        } else {
            break;
        }
    }
    Field::Ascii(String::from_utf8(buffer[..lenght].to_vec()).unwrap())
}
